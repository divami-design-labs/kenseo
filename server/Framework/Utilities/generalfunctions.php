<?php

/**
 * @package Utilities
 * TBC (Doc) - Evaluate whether these following functions are really required, and if so where.
 * 		Document each of the functions.
 *
 */

function __autoload($class_name) {
if(file_exists("$class_name . '.php'"))
   include_once $class_name . '.php';
}
  

/**
 * This utility function converts a rowset (of 2 columns) into an assoc array with the first element
 * being the key and the second being the value. It is assumed that the keys are unique.
 *
 * @param array $rowset
 * @return array
 */
function util_rowSetToAssocArray($rowset)
{
	// We have a 2D array. We need them as a name value pair with the first element being the key.
	$assocArray = array();
	foreach ($rowset as $row)
	{
		$assocArray[$row[0]] = $row[1] ;
	}
	return $assocArray ;
}
	

/**
 * This method generates a random string of a given length.
 *
 * @param int $max			length of string to be generated.
 * @return string			random string.
 */
function util_random_string($max=30)
{
	srand(time());
	
	$source = "abcdefghijklmnopqrstuvwxyz0123456789" ;
	$shuffled = str_shuffle($source);
	while (strlen($shuffled) < 3*$max)
	{
		$shuffled .= str_shuffle($source);
	}
	$start = rand(0, $max);
	return substr($shuffled, $start, $max);
	/*
	$chars = explode(" ", "a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9");
	for($i = 0; $i < $max; $i++){
		$rnd = array_rand($chars);
		$rtn .= base64_encode(md5($chars[$rnd]));
	}
	return substr(str_shuffle(strtolower($rtn)), 0, $max);
	 $key = '';
	$keys = array_merge(range(0, 9), range('a', 'z'));
	for ($i = 0; $i < $length; $i++) {
		$key .= $keys[array_rand($keys)];
	}
	return $key;
	*/
}

/**
 * This method is not actually currently used in the project. However, the $iv (initialization vector) that is
 * used in the project has been generated by this routine. Once generated, we hard code it, so this method does
 * not need to be called at runtime.
 *
 * @return binary			The initialization vector to be used by the encryption mechanism.
 */
function util_getiv()
{
	$iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB);
    $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);

    return $iv;
}

/**
 * This method decrypts the data with the given key. Please note that we use RIJNDAEL 256 bit encryption
 * and ECB_MODE encryption which doesnt actually use the key that is passed in. However, to satisfy PHP lint,
 * we must pass in a valid IV.
 *
 * @param string $crypted_id	The string of data (UUENCODED to be ASCII) that needs to be decrypted. We will first
 * 								uudecode it to get the actual binary encrypted data and then decrypt it.
 * @param string $key			The key with which to decrypt.
 * @param string $iv			Initialization vector (this is also a uuencoded value, so we must first decode).
 * @return string				Decrypted data.
 */
function util_decrypt_data($crypted_id, $key, $iv)
{
	// Currently, the production machine does not have support for mcrypt. Hence we do not
	// have the ability to encrypt/decrypt information. Only the cookie information is being requested
	// to be encrypted right now. It is decided that, for now it is not a security violation to skip
	// encryption of cookie data.
	return $crypted_id ;
	
	/*
	$iv = base64_decode($iv);
	$crypted_id = base64_decode($crypted_id);
	$decrypt_data = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, $crypted_id, MCRYPT_MODE_ECB, $iv);
	return str_replace("\x0", '', $decrypt_data);	
	*/
}

/**
 * This utility routine encrypts data using RIJNDAEL 256 bit encryption and ECB_MODE for encryption.
 * The IV that is passed in is not really used by the algo, but required by the encrypt module.
 *
 * @param string $plaintext		To be encrypted.
 * @param string $key			Key used for encryption.
 * @param string $iv			A uuencoded Initialization Vector.
 * @return string				A uuencoded string of encrypted data.
 */
function util_encrypt_data($plaintext, $key, $iv)
{
	// Currently, the production machine does not have support for mcrypt. Hence we do not
	// have the ability to encrypt/decrypt information. Only the cookie information is being requested
	// to be encrypted right now. It is decided that, for now it is not a security violation to skip
	// encryption of cookie data.
	return $plaintext ;
	
	/*
	$iv = base64_decode($iv);
	$crypted_data = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $plaintext, MCRYPT_MODE_ECB, $iv);
	$crypt_string = base64_encode($crypted_data);
	return $crypt_string;
	*/
}

	

/**
 * method to retrieve sql query from Querylanguage XML. Any placeholders will also be substituted based
 * on the parameter arrays passed in.
 *
 * @param string $queryName
 * @param array $replacements
 * @return string $query
 */
function getQuery( $queryName , $replacements = array()) 
{	
	$dbCon = Master::getDBConnectionManager() ;
	$begDelimiter = BEGDELIMITER ; 
	$endDelimiter = ENDDELIMITER ; 
	$patternDelimiter = PATTERNDELIMITER ;
	
	$arrReplacements = array();	$arrPatterns = array();
	
	foreach ($replacements as $key => $value)
	{
		// Dont quote the value if the Key starts with an @. This must be an object name.
		if ($key{0} == '@')
		{
			$key = substr($key, 1);
			$arrReplacements[] = $value ;
		}
		else
		{
			// this is the plain vanilla replacement with quotes.
			// The following function will ensure that arrays are quoted correctly as comma separated quoted vals.
			$arrReplacements[] = $dbCon->formatValue($value) ;
		}
		
		$arrPatterns[] = $patternDelimiter . $begDelimiter . $key . $endDelimiter . $patternDelimiter ;
	}
	
	if (!($query = Master::getQueryLanguage($queryName)))
	{
		throw new CustomException('EXC_MISSING_QUERY', $queryName);
	}

	$replacedQuery = preg_replace($arrPatterns, $arrReplacements, $query) ;
	
	$retValue = trim($replacedQuery);
	
	return $retValue ;	
}

/**
 * TBC (Doc) - Add Comments on usage. and change parameter names to reflect the usage model.
 */
function util_getColumnsValues( $arrReq, $arrList  )
{
	/*
	$list["primarycolumns"] = array(); $list["primaryvalues"] = array();
	if(is_array($arrList["primary"]))
	{ 
		foreach( $arrList["primary"] as $value )
		{
			$list["primarycolumns"][] = $value;
			$list["primaryvalues"][] = $arrReq[$value];
		}
	}
	*/
	foreach( $arrReq as $key => $value )
	{
		if(isset($arrList[$key]))
		{
			$list["columns"][] = $arrList[$key];
			$list["values"][] = $value;
		}
	}
	
	return $list;
}


/**
 * This function is used to walk an array and prepend the prefix to each element of the array
 *
 * @param unknown_type $item		The array item to alter
 * @param unknown_type $key			The key of this element. Not used by this function.
 * @param unknown_type $prefix		The prefix to prepend to the item.
 */
function util_array_values_prepend(&$item, $key, $prefix)
{
    $item = $prefix.$item;
}


/**
 * This function is used to figure out a name to display from various components.
 *
 * @param unknown_type $displayName
 * @param unknown_type $firstName
 * @param unknown_type $lastName
 * @param unknown_type $email
 * @return unknown
 */
function util_getUsableName($displayName, $firstName, $lastName, $email)
{
	$displayName = trim($displayName);
	if (!empty($displayName))
	{
		return $displayName ;
	}
	else
	{
		$displayName = trim($firstName . " " . $lastName);
		if (!empty($displayName))
		{
			return $displayName ;
		}
		
		$email = trim($email);
		if (!empty($email))
		{
			$parts = explode('@', $email);
			$displayName = (count($parts) > 0) ? ucfirst($parts[0]) : '' ;
		}
	}
	
	return $displayName ;
}

/**
 * This function used to return the common date time in server.
 */
function util_datetime()
{
		return date("Y-m-d H:i:s");
}


function util_array_change_case($input, $case)
{
	$output = array();
	if ($input && is_array($input))
	{
		foreach ($input as $key => $value)
		{
			$output[$key] = ($case == CASE_LOWER) ? strtolower($value) : strtoupper($value);
		}
	}
	return $output ;
}


/**
 * This function returns a union of 2 arrays, preserving the keys. If the keys are same,
 * the values in the second array overwrite those in the first.
 *
 * @param array $array1
 * @param array $array2
 */
function util_array_union($array1, $array2)
{
	$result = $array1;
	foreach ($array2 as $key => $value)
	{
		$result[$key] = $value ;
	}
	
	return $result ;
}


/**
 * This function works like the array_merge function but it also works for numerical keys
 * whereas array_merge does not overwrite numerical keys, but appends the values and renumbers
 * them, this function strictly overwrites the values of the first array with the second array
 * when the keys are same.
 *
 * @param array $array1
 * @param array $array2
 * @return array
 */
function util_array_merge_overwrite($array1, $array2)
{
	foreach ($array2 as $key => $value)
	{
		$array1[$key] = $value ;
	}
	return $array1 ;
}


/**
 * This function fills in an array with the specified keys and values. the built-in function array_fill_keys
 * is only available in PHP 5.2 and later. Hence this function is defined to provide equivalent
 * functionality for earlier versions. When the production system moves to 5.2 or later, we can
 * remove this function and replace all references with the built-in.
 *
 * @param array $keys	An array of keys
 * @param mixed $value	The value that needs to be filled in
 * @return array		A filled in array whose keys are $keys and values are $value.
 */
function util_array_fill_keys($keys, $value)
{
	if (!is_array($keys))
		return FALSE ;
	$filledArray = array();
	foreach ($keys as $key)
	{
		$filledArray[$key] = $value ;
	}
	
	return $filledArray ;
}


/**
 * This function returns the default temp directory. the built-in function sys_get_temp_dir
 * is only available in PHP 5.2 and later. Hence this function is defined to provide equivalent
 * functionality for earlier versions. When the production system moves to 5.2 or later, we can
 * remove this function and replace all references with the built-in.
 *
 * @return unknown
 */
function util_sys_get_temp_dir()
{
	if (function_exists("sys_get_temp_dir"))
		return sys_get_temp_dir();
	else
		return "/tmp";
}


function util_oneway_encryption( $data )
{
	return sha1($data);
}


/*
 * This function updates a table based on an object's fields. A full list of columns and the table name and the
 * where clause need to be passed in.
 */
function util_updateTableFromArray($tableName, $fieldList, $data, $whereClause)
{
	$updFields = array();
	$updValues = array();
	foreach ($fieldList as $field) {
		if (property_exists($data, $field)) {
			array_push($updFields, $field);
			array_push($updValues, $data->$field);
		}
	}
	
	if (count($updFields) > 0) {
		$db = Master::getDBConnectionManager();
		return $db->updateTable($tableName, $updFields, $updValues, $whereClause);
	} else {
		return -1;
	}
}


/*
 * This function updates a table based on an object's fields. A full list of columns and the table name and the
 * where clause need to be passed in.
 */
function util_insertTableFromArray($tableName, $fieldList, $data)
{
	$updFields = array();
	$updValues = array();
	foreach ($fieldList as $field) {
		if (property_exists($data, $field)) {
			array_push($updFields, $field);
			array_push($updValues, $data->$field);
		}
	}
	
	$db = Master::getDBConnectionManager();
	return $db->insertSingleRow($tableName, $updFields, $updValues);
}

function util_getLimitClause($data)
{
	if (property_exists($data, 'count')) {
		$count = $data->count;
		$index = (property_exists($data, 'index')) ? $data->index : 0;
		$data->index = $index;
		$limitClause = " LIMIT $index, $count " ;
	} else {
		$limitClause = "" ;
	}
	
	return $limitClause;
}


function util_simpleURLExec($url, $paramStr)
{
	$sendUrl = $url . "?" . $paramStr;
	Master::getLogManager()->log(DEBUG, MOD_MAIN, "Sending URL: %s", $sendUrl);

	$ch = curl_init($sendUrl);
	curl_setopt_array($ch, array(CURLOPT_AUTOREFERER => TRUE, CURLOPT_FAILONERROR => TRUE, CURLOPT_HEADER => FALSE, CURLOPT_RETURNTRANSFER => TRUE));

	$resultStr = curl_exec($ch);
	// Check if any error occured
	if(!curl_errno($ch)) {
		Master::getLogManager()->log(DEBUG, MOD_MAIN, "Results: %s", $resultStr);
	} else {
		$resultStr = null;
	}
	curl_close($ch);
	
	// return the result string or NULL if we encountered an error.
	return $resultStr;
}


function util_redirectToURL($url) {
	Master::getLogManager()->log(DEBUG, MOD_MAIN, "redirecting to URL: %s", $url);
	header("Location: " . $url);
	die();
}


?>